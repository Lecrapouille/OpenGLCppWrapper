# OpenGLCppWrapper

## What is OpenGLCppWrapper Library ?

OpenGLCppWrapper is a C++11 wrapper for writing OpenGL `Core Profile` applications in few lines of code. This API, contrary to other C++ OpenGL API really uses object-oriented and does not just content to give a C++ flavor name to OpenGL routines. It hides for you the complexity of calling in the correct order OpenGL functions as well as passing correct parameters to them. You, as developper, will have just to deal with writing your OpenGL shaders (GLSL language) and the OpenGLCppWrapper will compile them and instantiate classes wrapping OpenGL VAOs, VBOs, textures. Then you will have just to write the code filling your 3d models by calling your desired textures and loading data for filling your VBOs (such as vertices position, texture coordinates, normals ..) and which and when 3D model to paint. Nothing more complex! This API also manages OpenGL object lifetime: it makes the transfer of "dirty" CPU data (from your C++ space memory point of view) to the graphics card memory (VBOs, textures).

**Warning:** Do not confuse Core Profile OpenGL (>= 2.2) with Legacy OpenGL (<= 2.1). This API does not manage OpenGL Legacy but manages OpenGL version >= 3.0.

**Warning:** This library is not a game engine but just an oriented object wrapper for OpenGL that can be used for a game engine.

### Tutorials, Examples and API documentation

* [Tutorials](https://github.com/Lecrapouille/OpenGLCppWrapper/blob/master/doc/tutorials/Core.md)
* [Examples](https://github.com/Lecrapouille/OpenGLCppWrapper/blob/master/examples/README.md)
* [Code Architecture](https://github.com/Lecrapouille/OpenGLCppWrapper/blob/master/doc/Architecture.md)
* Doxygen documention can be generated by typing `make doc`.

## Compilation/Installation

### Prerequisite

This project depends on:
* [MyMakefile](https://github.com/Lecrapouille/MyMakefile) my GitHub Makefile project used for compiling all my GitHub projects. It's automatically cloned as git submodule.
* [OpenGLCppWrapper-data](https://github.com/Lecrapouille/OpenGLCppWrapper-data) this repo contains all textures needed by examples. This repo is downloaded by a Makefile rule.
* [SOIL](https://github.com/kbranigan/Simple-OpenGL-Image-Library.git) for loading picture files (jpeg, png ...). This library is downloaded by a Makefile rule.
* [imgui](https://github.com/ocornut/imgui) for adding widgets to your applications. This library is downloaded by a Makefile rule.
* [backward-cpp](https://github.com/bombela/backward-cpp), only needed for debug purpose, display stack when a crash occured. This library is downloaded by a Makefile rule.

##### Ubuntu, Debian:

```sh
sudo apt-get update && apt-get install libglew-dev libglfw3-dev libbz2-dev
```

Optionally if you want to write/launch unit tests, install `crpcut`
```sh
add-apt-repository ppa:jonlar/crpcut
sudo apt-get update && apt-get install crpcut crpcut-dev
```

##### Mac OS X:
```sh
brew install glfw glew
```

### Compilation

Made for Linux, it also works for OS X (while I can hardly test on it because I have to borrow a MacBook). Not yet working for Windows because I do not have windows for developping (and, as well, I need help on completing my Makefile project).

To download the project, its external libraries and compile the API with its examples:
```sh
git clone --recurse-submodules https://github.com/Lecrapouille/OpenGLCppWrapper.git --depth=1
cd cd OpenGLCppWrapper
./build.sh
```

Calling `build.sh` will do:
```sh
make download-external-libs
make compile-external-libs
make
cd examples
make
```

To compile OpenGLCppWrapper:
```sh
make download-external-libs
make compile-external-libs
make
```

A `build/` folder shall have been created containing the compiled and runnable files. Two libraries (one static the second dynamic) shall also be present. You can use them for your project.

If, after that, you want to modify code source, just do `make`. You can type `make help` for displaying rules.

**Note:** Makefile rules `download-external-libs` and `compile-external-libs` play the same role than a recursive git clone: they will download, compile (but not install) GitHub libraries like: Backward, SOIL and Dear IMgui. You have to do it once (or for updating).

**Note:** I hate git submodules: it always make things painful. `repo` with its manifests is a bit overkill, so I prefer Makefile rules or script shell.

To compile API examples:
```sh
make download-resources
cd OpenGLCppWrapper/examples/00_Core
make -j4
```

A `build/` folder shall have been created containing the compiled and runnable files. Two libraries (one static the second dynamic) shall also be present. You can use them for your project.

Run examples:
```sh
./build/OpenGLExamples
```

Will display the list of possible examples. Type `./build/OpenGLExamples 1` for example for running the 1st example.

### Installation

Multiple versions of this library can coexist thanks to their versioning number.
```sh
cd OpenGLCppWrapper
make download-external-libs
make compile-external-libs
make -j4
sudo make install
```

This will install:
* in `/usr/lib`: the static and shared libraries libOpenGLCppWrapper.
* in `/usr/include/openglcppwrapper-<version>`: all headers files (hpp).
* in `/usr/lib/pkgconfig`: a pkg confile file for linking this API to your project.
* in `/usr/share/OpenGLCppWrapper/<version>/`: documentation, examples and other files.

Check the presence of libraries in your system:
```sh
cd /usr/lib
ls -la libOpenGLCppWrapper*
```
Or better:
```
pkg-config openglcppwrapper --libs
```

### Unit tests

```sh
cd OpenGLCppWrapper/tests
make coverage -j4
```

If all tests passed, a coverage report is created inside `doc/coverage/` and the `index.html` is opened automatically.

## How to use OpenGLCppWrapper in your project?

Add the include in your cpp file: `# include <OpenGLCppWrapper/OpenGLCppWrapper.hpp>`

In debug mode, you can use the following macros:
* `-DCHECK_OPENGL` for checking bad parameters passed to OpenGL routines.
* `-DENABLE_DEBUG` for activating console logs for debugging.

Compile using the pkg-config tool to add compilation flags to GCC or clang:
* CFLAGS=\`pkg-config openglcppwrapper --cflags\`
* LDFLAGS=\`pkg-config openglcppwrapper --libs\`
* Note: in pkg-config instead of openglcppwrapper which refers to the last installed version,
you can specify your desired version (for example: openglcppwrapper-0.6).

Example with a simple file main.cpp:
```
g++ -W -Wall --std=c++11 main.cpp -o prog `pkg-config openglcppwrapper --cflags --libs`
```

## Why another C++ wrapper for OpenGL?

Short answer: I disliked others API I found on Github! Long answer:

* Contrary to legacy OpenGL, learning modern OpenGL (aka OpenGL Core Profile), is more difficult for beginners.

* As a beginner of OpenGL Core, I always get confused by the order of creation/binding of OpenGL objects. With OpenGLCppWrapper, you'll do not have to really know what is OpenGL VBOs, VAOs, framebuffer, shader attributes, ... and in what order they have to be created or bound. What you probably prefer to deal with questions like: "what texture fit the best to my model?" or "What is the list of triangles for my model?" but certainly not low-level issue questions like "is myTexture.jpg is bound to GL_TEXTURE0 or GL_TEXTURE1 ?".

* When working on my personal project
[SimTaDyn](https://github.com/Lecrapouille/SimTaDyn) I was looking for a C++ API wrapping OpenGL routines. The first need was to hide the OpenGL boilerplate. I looked for such a kind of OpenGL library on GitHub but I found none which allowed me to write OpenGL scenes in few lines. The second need, is that OpenGL does not manage dynamic size VBOs easily (as far as I know). I needed to edit maps with an arbitrary number of nodes and arcs which is problematic with fixed size VBO (OpenGL is made for games and characters are rendering with almost the same number of vertices (if we except tessellation with geometry shaders).

* C++ APIs I saw on GitHub just give a C++ flavor'ish taste to OpenGL C functions. None of them have real class inheritance wrapping OpenGL objects and encapsulate for hiding the misery of calling routines. As a consequence, you still have to deal with the correct order of calling routines.

* APIs like [ogl](https://github.com/opengl-tutorials/ogl) or [OOGL](https://github.com/Overv/OOGL) or [gl](https://github.com/acdemiralp/gl) are wrong (even with thousands of stars) because there is too much code like `glBindBuffer`, `BindAttribute(... 3, 42 * sizeof(float))` or `glVertexAttribPointer`, `program.set_uniform(program.uniform_location` that I absolutely do not want to see in a high-level code.

* I also wanted an API that not only content to initialize VBOs during the init phase (meshes, color, textures ...), but that also allows you to manipulate your 3D scene data during the runtime from the CPU point of view: the API will transmit automatically to the GPU all modified elements for their display. This is, of course, less performant that manipulating them from shaders code, but this offers you extra flexibility (for scientific tools for example).

* The only API demarking to others was [Glumpy](https://github.com/glumpy/glumpy). It was the API I was looking for but unfortunately written in Python! I had to make its portage into C++. I also discovered later [opengl4csharp](https://github.com/giawa/opengl4csharp), written in C#, quite similar to Glumpy but I think some designs are less good.

* I found no good C++ OpenGL wrapper API, so I make my own largely inspired by Glumpy which takes the opposite direction over OpenGL tutorials: it does not start with a list of triangles, to push them in VBOs and finish coding with shaders (and depending on which OpenGL version, uses or not a VAO) it does the inverse: it starts from shaders and hides for you the generation of VBOs, attributes, uniforms, texture samplers. As a developper, you'll have just to request the shader program to instanciate a new 3D model (aka VAO), initialize it with data the shader needs: vertices, colors, texture positions. Finally paint the model with the bound shader.

* The number of public interfaces of OpenGLCppWrapper is reduced as much as possible. Only OpenGL constants used as parameters in public methods are wrapped by C++ enum for using the strong type checking during the compilation of the project, avoiding to pass 'carrots' while 'potatoes' were expected.

## Drawbacks

As drawbacks, this API is less cache friendly than calling directly your OpenGL routines (due to a lot of if-then-else, smart pointers and dynamic cast). This is the price of hiding the complexity and staying generic.

## Credits

This API is largely inspired by projects such as:
* [Glumpy](https://github.com/glumpy/glumpy) python project.
* [opengl4csharp](https://github.com/giawa/opengl4csharp) C# project.

**Note: OpenGLCppWrapper is not a full-feature portage of Glumpy or opengl4csharp**

* The first reason is due to the fact that C++ is a strongly typed language that does not offer the same flexibility than python. For example in C++: storing template classes in the same container is not possible.

* The second reason is, maybe I'm totally wrong, that Glumpy does not use by default VAOs (because it uses OpenGL < 3.3) but access to VBOs through OpenGL program attributes. This also perturbs me because in the case of you have several models (therefore several VAOs) to paint this seems problematic to draw them. In my API only VAOs have to be created. They hold VBOs and texture once bound to GLProgram. The result is equivalent to Glumpy but the internal code is different. See this file
[differences](https://github.com/Lecrapouille/OpenGLCppWrapper/blob/master/doc/Differences.md) for more differences.

